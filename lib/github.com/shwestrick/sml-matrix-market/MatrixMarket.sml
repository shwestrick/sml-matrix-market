functor MatrixMarket (structure I: INTEGER structure R: REAL):
sig

  (* "Array" matrix market format is in column-major format.
   * Note that the encoding of the columns depends on symmetries! If the
   * data is either symmetric, skew-symmetric, or Hermitian, only the lower
   * triangular portion is included, and the 2D structure will therefore be
   * jagged.
   *)
  structure Columns:
  sig
    datatype columns =
      Real of R.real array array
    | Integer of I.int array array
    | Complex of {re: R.real, im: R.real} array array
    type t = columns

    val show: t -> string
  end


  structure Values:
  sig
    datatype values =
      Real of R.real array
    | Integer of I.int array
    | Complex of {re: R.real, im: R.real} array
    type t = values

    val show: t -> string
  end


  datatype data =
    Array of Columns.t
  | Coordinate of
      {row_indices: I.int array, col_indices: I.int array, values: Values.t}
  | Pattern of {row_indices: I.int array, col_indices: I.int array}


  (* The data stored in MatrixMarket files has a few ad-hoc compression
   * schemes, taking advantage of symmetries commonly found in matrices:
   *
   *   General: no symmetry, all entries are included in the data.
   *
   *   Symmetric: matrix is symmetric along the diagonal (M[i,j] = M[j,i]).
   *     The data includes only the lower triangular portion, including
   *     diagonal entries, which can be non-zero.
   *
   *   SkewSymmetric: same as Symmetric, but the data along the diagonal is 0
   *     and is excluded.
   *
   *   Hermitian: as the name suggests. The values must be complex, and only
   *     the lower triangular portion of the matrix is included in the data,
   *     including the diagonal, which can be non-zero. The upper triangular
   *     portion is excluded; this can be recovered according to the definition
   *     of Hermitian matrices: M[i,j] = ComplexConjugate(M[j,i]).
   *)
  datatype symmetry =
    General
  | SkewSymmetric
  | Symmetric
  | Hermitian

  datatype matrix =
    Matrix of {num_cols: int, num_rows: int, data: data, symm: symmetry}


  val showData: data -> string
  val showSymmetry: symmetry -> string
  val showMatrix: matrix -> string


  (* read_file(path) -> matrix *)
  val read_file: string -> matrix

end =
struct

  fun showArray f a =
    "[" ^ String.concatWith "," (List.map f (Array.foldr op:: [] a)) ^ "]"

  structure Columns =
  struct
    datatype columns =
      Real of R.real array array
    | Integer of I.int array array
    | Complex of {re: R.real, im: R.real} array array
    type t = columns

    (* generated by smlgen / tweaked by hand *)
    val showColumns =
      fn Real t0 => "Real " ^ "(" ^ showArray (showArray R.toString) t0 ^ ")"
       | Integer t1 =>
        "Integer " ^ "(" ^ showArray (showArray I.toString) t1 ^ ")"
       | Complex t2 =>
        "Complex " ^ "("
        ^
        showArray
          (showArray (fn {re = t0, im = t1} =>
             "{"
             ^
             String.concatWith ", "
               ["re = " ^ R.toString t0, "im = " ^ R.toString t1] ^ "}")) t2
        ^ ")"
    val show = showColumns
  end


  structure Values =
  struct
    datatype values =
      Real of R.real array
    | Integer of I.int array
    | Complex of {re: R.real, im: R.real} array
    type t = values

    (* generated by smlgen / tweaked by hand *)
    val showValues =
      fn Real t0 => "Real " ^ "(" ^ showArray R.toString t0 ^ ")"
       | Integer t1 => "Integer " ^ "(" ^ showArray I.toString t1 ^ ")"
       | Complex t2 =>
        "Complex " ^ "("
        ^
        showArray
          (fn {re = t0, im = t1} =>
             "{"
             ^
             String.concatWith ", "
               ["re = " ^ R.toString t0, "im = " ^ R.toString t1] ^ "}") t2
        ^ ")"
    val show = showValues
  end


  datatype data =
    Array of Columns.t
  | Coordinate of
      {row_indices: I.int array, col_indices: I.int array, values: Values.t}
  | Pattern of {row_indices: I.int array, col_indices: I.int array}

  (* generated by smlgen / tweaked by hand *)
  val showData =
    fn Array t0 => "Array " ^ "(" ^ Columns.show t0 ^ ")"
     | Coordinate {row_indices = t1, col_indices = t2, values = t3} =>
      "Coordinate " ^ "{"
      ^
      String.concatWith ", "
        [ "row_indices = " ^ showArray I.toString t1
        , "col_indices = " ^ showArray I.toString t2
        , "values = " ^ Values.show t3
        ] ^ "}"
     | Pattern {row_indices = t4, col_indices = t5} =>
      "Pattern " ^ "{"
      ^
      String.concatWith ", "
        [ "row_indices = " ^ showArray I.toString t4
        , "col_indices = " ^ showArray I.toString t5
        ] ^ "}"


  datatype symmetry = General | SkewSymmetric | Symmetric | Hermitian

  (* generated by smlgen *)
  val showSymmetry =
    fn General => "General"
     | SkewSymmetric => "SkewSymmetric"
     | Symmetric => "Symmetric"
     | Hermitian => "Hermitian"


  datatype matrix =
    Matrix of {num_cols: int, num_rows: int, data: data, symm: symmetry}


  (* generated by smlgen / tweaked by hand *)
  val showMatrix =
    fn Matrix {num_cols = t0, num_rows = t1, data = t2, symm = t3} =>
      "Matrix " ^ "{"
      ^
      String.concatWith ", "
        [ "num_rows = " ^ Int.toString t1
        , "num_cols = " ^ Int.toString t0
        , "symm = " ^ showSymmetry t3
        , "data = " ^ showData t2
        ] ^ "}"


  (* check if str is at the beginning of chars *)
  fun begins_with (str: string) (chars: char Seq.t) =
    String.size str <= Seq.length chars
    andalso
    Util.all (0, String.size str) (fn i =>
      String.sub (str, i) = Seq.nth chars i)


  fun error path msg =
    raise Fail ("MatrixMarket: " ^ path ^ ": " ^ msg)

  fun skip_whitespace chars =
    case
      FindFirst.findFirstSerial (0, Seq.length chars)
        (not o Char.isSpace o Seq.nth chars)
    of
      SOME i => Seq.drop chars i
    | NONE => Seq.drop chars (Seq.length chars)

  fun skip_until_whitespace chars =
    case
      FindFirst.findFirstSerial (0, Seq.length chars)
        (Char.isSpace o Seq.nth chars)
    of
      SOME i => Seq.drop chars i
    | NONE => Seq.drop chars (Seq.length chars)


  structure Header =
  struct
    datatype first_field = Coordinate | Array
    datatype second_field = Real | Integer | Complex | Pattern
    datatype third_field = General | Symmetric | SkewSymmetric | Hermitian

    fun parse path (chars: char Seq.t) =
      let
        fun expect chars str {err: string} =
          if begins_with str chars then Seq.drop chars (String.size str)
          else error path err

        fun test chars str =
          if begins_with str chars then SOME (Seq.drop chars (String.size str))
          else NONE

        val chars =
          expect chars "%%MatrixMarket matrix" {err = "not a MatrixMarket file"}


        fun try_each chars err_msg tests =
          case tests of
            [] => error path err_msg
          | (str, result) :: tests' =>
              case test chars str of
                SOME chars => (result, chars)
              | NONE => try_each chars err_msg tests'


        val chars = skip_whitespace chars
        val (first_field, chars) =
          try_each chars
            "first field in header must be one of: coordinate, array"
            [("coordinate", Coordinate), ("array", Array)]

        val chars = skip_whitespace chars
        val (second_field, chars) =
          try_each chars
            "second field in header must be one of: real, integer, complex, pattern"
            [ ("real", Real)
            , ("integer", Integer)
            , ("complex", Complex)
            , ("pattern", Pattern)
            ]

        val chars = skip_whitespace chars
        val (third_field, chars) =
          try_each chars
            "third field in header must be one of: general, symmetric, skew-symmetric, Hermitian"
            [ ("general", General)
            , ("symmetric", Symmetric)
            , ("skew-symmetric", SkewSymmetric)
            , ("Hermitian", Hermitian)
            ]
      in
        (first_field, second_field, third_field)
      end

  end


  fun triangular_number n =
    if n mod 2 = 0 then (n div 2) * (n + 1) else ((n + 1) div 2) * n


  fun check_num_entries {num_rows, num_cols, num_entries, symm, path} =
    case num_entries of
      NONE => ()
    | SOME ne =>
        let
          val expected_num_entries =
            case symm of
              General => num_rows * num_cols
            | Symmetric => triangular_number num_rows
            | SkewSymmetric => triangular_number (num_rows - 1)
            | Hermitian => triangular_number num_rows
        in
          if ne = expected_num_entries then
            ()
          else
            error path
              ("bad matrix: number of entries is " ^ Int.toString ne
               ^ " but expected " ^ Int.toString expected_num_entries)
        end


  fun emp () = Array.fromList []


  fun is_digit c =
    Char.>= (c, #"0") andalso Char.<= (c, #"9")

  fun digit_char_to_word64 c =
    Word64.- (Word64.fromInt (Char.ord c), 0w48) (* 48 = ord(#"0") *)

  fun push_digit_char acc c =
    Word64.* (0w10, acc) + digit_char_to_word64 c

  fun maybe_parse_digits (chars: char Seq.t) :
    {result: Word64.word, remaining: char Seq.t} option =
    let
      val (a, start, n) = ArraySlice.base chars
      val stop = start + n

      fun loop (acc, i) =
        if i >= stop then
          (acc, i)
        else
          let
            val c = Array.sub (a, i)
          in
            if is_digit c then loop (push_digit_char acc c, i + 1) else (acc, i)
          end
    in
      if n = 0 then
        NONE
      else
        let
          val first_char = Array.sub (a, start)
        in
          if is_digit first_char then
            let val (acc, i) = loop (digit_char_to_word64 first_char, start + 1)
            in SOME {result = acc, remaining = Seq.drop chars (i - start)}
            end
          else
            NONE
        end
    end


  fun maybe_parse_nonnegative_integer chars =
    Option.map
      (fn {result, remaining} =>
         {result = Word64.toInt result, remaining = remaining})
      (maybe_parse_digits chars)


  fun parse_nonnegative_integer path chars :
    {result: int, remaining: char Seq.t} =
    case maybe_parse_nonnegative_integer chars of
      SOME xxx => xxx
    | NONE => error path "invalid nonnegative integer"


  fun parse_integer path chars : {result: int, remaining: char Seq.t} =
    if Seq.length chars > 0 andalso Seq.nth chars 0 <> #"-" then
      parse_nonnegative_integer path chars
    else
      let
        val {result, remaining} = parse_nonnegative_integer path
          (Seq.drop chars 1)
      in
        {result = ~result, remaining = remaining}
      end


  (* TODO: This is fairly slow? *)
  fun parse_real path chars =
    let
      val stop =
        case
          FindFirst.findFirstSerial (0, Seq.length chars)
            (Char.isSpace o Seq.nth chars)
        of
          NONE => Seq.length chars
        | SOME i => i
    in
      case Parse.parseReal (Seq.take chars stop) of
        SOME r => (r, Seq.drop chars stop)
      | NONE => error path "invalid real"
    end


  fun parse_coordinate {num_rows, num_cols, absolute_line, path} chars =
    let
      val {result = r, remaining = chars} = parse_nonnegative_integer path chars
      val chars = skip_whitespace chars
      val {result = c, remaining = chars} = parse_nonnegative_integer path chars
    in
      if 0 < r andalso r <= num_rows then
        ()
      else
        error path
          ("line " ^ Int.toString (1 + absolute_line) ^ ": row index "
           ^ Int.toString r ^ " out of bounds");

      if 0 < c andalso c <= num_cols then
        ()
      else
        error path
          ("line " ^ Int.toString (1 + absolute_line) ^ ": col index "
           ^ Int.toString c ^ " out of bounds");

      (r, c, chars)
    end


  fun r_from_real x =
    R.fromLarge IEEEReal.TO_NEAREST (Real.toLarge x)


  fun parse_coordinate_real_data
    { path
    , contents
    , get_line_range
    , start_line
    , num_rows
    , num_cols
    , num_entries
    } =
    let
      fun make_line i =
        let val (start, stop) = get_line_range i
        in Seq.subseq contents (start, stop - start)
        end

      val row_indices = ForkJoin.alloc num_entries
      val col_indices = ForkJoin.alloc num_entries
      val values = ForkJoin.alloc num_entries

      (* parse entries and write results *)
      val () = ForkJoin.parfor 1000 (0, num_entries) (fn i =>
        let
          val absolute_line = start_line + i
          val cs = make_line absolute_line
          val cs = skip_whitespace cs
          val (r, c, cs) =
            parse_coordinate
              { num_rows = num_rows
              , num_cols = num_cols
              , absolute_line = absolute_line
              , path = path
              } cs
          val cs = skip_whitespace cs
          val (v, _) = parse_real path cs
        in
          Array.update (row_indices, i, I.fromInt r);
          Array.update (col_indices, i, I.fromInt c);
          Array.update (values, i, r_from_real v)
        end)
    in
      Coordinate
        { row_indices = row_indices
        , col_indices = col_indices
        , values = Values.Real values
        }
    end


  fun parse_coordinate_complex_data
    { path
    , contents
    , get_line_range
    , start_line
    , num_rows
    , num_cols
    , num_entries
    } =
    let
      fun make_line i =
        let val (start, stop) = get_line_range i
        in Seq.subseq contents (start, stop - start)
        end

      val row_indices = ForkJoin.alloc num_entries
      val col_indices = ForkJoin.alloc num_entries
      val values = ForkJoin.alloc num_entries

      (* parse entries and write results *)
      val () = ForkJoin.parfor 1000 (0, num_entries) (fn i =>
        let
          val absolute_line = start_line + i
          val cs = make_line absolute_line
          val cs = skip_whitespace cs
          val (r, c, cs) =
            parse_coordinate
              { num_rows = num_rows
              , num_cols = num_cols
              , absolute_line = absolute_line
              , path = path
              } cs
          val cs = skip_whitespace cs
          val (re, cs) = parse_real path cs
          val cs = skip_whitespace cs
          val (im, _) = parse_real path cs
        in
          Array.update (row_indices, i, I.fromInt r);
          Array.update (col_indices, i, I.fromInt c);
          Array.update (values, i, {re = r_from_real re, im = r_from_real im})
        end)
    in
      Coordinate
        { row_indices = row_indices
        , col_indices = col_indices
        , values = Values.Complex values
        }
    end


  fun parse_coordinate_integer_data
    { path
    , contents
    , get_line_range
    , start_line
    , num_rows
    , num_cols
    , num_entries
    } =
    let
      fun make_line i =
        let val (start, stop) = get_line_range i
        in Seq.subseq contents (start, stop - start)
        end

      val row_indices = ForkJoin.alloc num_entries
      val col_indices = ForkJoin.alloc num_entries
      val values = ForkJoin.alloc num_entries

      (* parse entries and write results *)
      val () = ForkJoin.parfor 1000 (0, num_entries) (fn i =>
        let
          val absolute_line = start_line + i
          val cs = make_line absolute_line
          val cs = skip_whitespace cs
          val (r, c, cs) =
            parse_coordinate
              { num_rows = num_rows
              , num_cols = num_cols
              , absolute_line = absolute_line
              , path = path
              } cs
          val cs = skip_whitespace cs
          val v = #result (parse_integer path cs)
        in
          Array.update (row_indices, i, I.fromInt r);
          Array.update (col_indices, i, I.fromInt c);
          Array.update (values, i, I.fromInt v)
        end)
    in
      Coordinate
        { row_indices = row_indices
        , col_indices = col_indices
        , values = Values.Integer values
        }
    end


  fun parse_coordinate_pattern_data
    { path
    , contents
    , get_line_range
    , start_line
    , num_rows
    , num_cols
    , num_entries
    } =
    let
      fun make_line i =
        let val (start, stop) = get_line_range i
        in Seq.subseq contents (start, stop - start)
        end

      val row_indices = ForkJoin.alloc num_entries
      val col_indices = ForkJoin.alloc num_entries

      (* parse entries and write results *)
      val () = ForkJoin.parfor 1000 (0, num_entries) (fn i =>
        let
          val absolute_line = start_line + i
          val cs = make_line absolute_line
          val cs = skip_whitespace cs
          val (r, c, _) =
            parse_coordinate
              { num_rows = num_rows
              , num_cols = num_cols
              , absolute_line = absolute_line
              , path = path
              } cs
        in
          Array.update (row_indices, i, I.fromInt r);
          Array.update (col_indices, i, I.fromInt c)
        end)
    in
      Pattern {row_indices = row_indices, col_indices = col_indices}
    end


  fun read_file (path: string) =
    let
      val contents = ReadFile.contentsSeq path

      val (num_lines, get_line_range) =
        Tokenize.tokenRanges (fn c => c = #"\n") contents

      fun make_line i =
        let val (start, stop) = get_line_range i
        in Seq.subseq contents (start, stop - start)
        end

      val () =
        if num_lines > 0 then ()
        else error path "invalid file: not enough lines to parse"

      val (f1, f2, f3) = Header.parse path (make_line 0)

      val symm =
        case f3 of
          Header.General => General
        | Header.Symmetric => Symmetric
        | Header.SkewSymmetric => SkewSymmetric
        | Header.Hermitian => Hermitian

      val first_non_comment_line =
        valOf (FindFirst.findFirst 2 (0, num_lines) (fn i =>
          let val (start, stop) = get_line_range i
          in stop > start andalso Seq.nth contents start <> #"%"
          end))
        handle Option => error path "missing number of rows and columns"

      val (num_rows: int, num_cols: int, num_entries: int option) =
        let
          val cs = make_line first_non_comment_line
          val cs = skip_whitespace cs
          val {result = nr, remaining = cs} = parse_nonnegative_integer path cs
          val cs = skip_whitespace cs
          val {result = nc, remaining = cs} = parse_nonnegative_integer path cs
          val cs = skip_whitespace cs
          val ne = Option.map #result (maybe_parse_nonnegative_integer cs)
        in
          (nr, nc, ne)
        end

      (* check squareness if needed *)
      val () =
        case symm of
          General => ()
        | _ =>
            if num_rows = num_cols then
              ()
            else
              error path
                ("bad matrix: header claims " ^ showSymmetry symm
                 ^ " but matrix is non-square")

      (* val _ =
        Option.app (fn x => print ("num_entries " ^ Int.toString x ^ "\n"))
          num_entries *)

      val data =
        case f1 of
          Header.Coordinate =>
            let
              val num_entries =
                valOf num_entries
                handle Option =>
                  error path "missing number of entries for coordinate format"

              val start_line = first_non_comment_line + 1
              val stop_line = start_line + num_entries
              val () =
                if stop_line <= num_lines then
                  ()
                else
                  error path
                    ("not enough lines to parse: expected "
                     ^ Int.toString num_entries ^ " entries but found only "
                     ^ Int.toString (num_lines - start_line))
            in
              case f2 of
                Header.Real =>
                  parse_coordinate_real_data
                    { path = path
                    , contents = contents
                    , get_line_range = get_line_range
                    , start_line = start_line
                    , num_rows = num_rows
                    , num_cols = num_cols
                    , num_entries = num_entries
                    }
              | Header.Integer =>
                  parse_coordinate_integer_data
                    { path = path
                    , contents = contents
                    , get_line_range = get_line_range
                    , start_line = start_line
                    , num_rows = num_rows
                    , num_cols = num_cols
                    , num_entries = num_entries
                    }
              | Header.Complex =>
                  parse_coordinate_complex_data
                    { path = path
                    , contents = contents
                    , get_line_range = get_line_range
                    , start_line = start_line
                    , num_rows = num_rows
                    , num_cols = num_cols
                    , num_entries = num_entries
                    }
              | Header.Pattern =>
                  parse_coordinate_pattern_data
                    { path = path
                    , contents = contents
                    , get_line_range = get_line_range
                    , start_line = start_line
                    , num_rows = num_rows
                    , num_cols = num_cols
                    , num_entries = num_entries
                    }
            end

        | Header.Array =>
            let
              val () = check_num_entries
                { num_rows = num_rows
                , num_cols = num_cols
                , num_entries = num_entries
                , symm = symm
                , path = path
                }
            in
              case f2 of
                Header.Real => Array (Columns.Real (emp ()))
              | Header.Integer => Array (Columns.Integer (emp ()))
              | Header.Complex => Array (Columns.Complex (emp ()))
              | Header.Pattern =>
                  error path
                    "invalid header: array cannot be combined with pattern"
            end
    in
      print
        "[MatrixMarket.read_file: WARNING: work-in-progress: function not completed yet]\n";

      Matrix
        {num_cols = num_cols, num_rows = num_rows, data = data, symm = symm}
    end

end
