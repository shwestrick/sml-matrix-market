functor MatrixMarket (structure I: INTEGER structure R: REAL):
sig

  (* "array" matrix market format is in column-major format *)
  structure Columns:
  sig
    datatype columns =
      Real of R.real array array
    | Integer of I.int array array
    | Complex of {re: R.real, im: R.real} array array
    type t = columns

    val show: t -> string
  end


  structure Values:
  sig
    datatype values =
      Real of R.real array
    | Integer of I.int array array
    | Complex of {re: R.real, im: R.real} array
    type t = values

    val show: t -> string
  end


  datatype data =
    Array of Columns.t
  | Coordinate of
      {row_indices: I.int array, col_indices: I.int array, values: Values.t}
  | Pattern of {row_indices: I.int array, col_indices: I.int array}


  (* The data stored in MatrixMarket files has a few ad-hoc compression
   * schemes, taking advantage of symmetries commonly found in matrices:
   *
   *   General: no symmetry, all entries are included in the data.
   *
   *   Symmetric: matrix is symmetric along the diagonal (M[i,j] = M[j,i]).
   *     The data includes only the lower triangular portion, including
   *     diagonal entries, which can be non-zero.
   *
   *   SkewSymmetric: same as Symmetric, but the data along the diagonal is 0
   *     and is excluded.
   *
   *   Hermitian: as the name suggests. The values must be complex, and only
   *     the lower triangular portion of the matrix is included in the data,
   *     including the diagonal, which can be non-zero. The upper triangular
   *     portion is excluded; this can be recovered according to the definition
   *     of Hermitian matrices: M[i,j] = ComplexConjugate(M[j,i]).
   *)
  datatype symmetry =
    General
  | SkewSymmetric
  | Symmetric
  | Hermitian

  datatype matrix =
    Matrix of {width: int, height: int, data: data, symm: symmetry}


  val showData: data -> string
  val showSymmetry: symmetry -> string
  val showMatrix: matrix -> string


  (* read_file(path) -> matrix *)
  val read_file: string -> matrix

end =
struct

  fun showArray f a =
    "[" ^ String.concatWith "," (List.map f (Array.foldr op:: [] a)) ^ "]"

  structure Columns =
  struct
    datatype columns =
      Real of R.real array array
    | Integer of I.int array array
    | Complex of {re: R.real, im: R.real} array array
    type t = columns

    (* generated by smlgen / tweaked by hand *)
    val showColumns =
      fn Real t0 => "Real " ^ "(" ^ showArray (showArray R.toString) t0 ^ ")"
       | Integer t1 =>
        "Integer " ^ "(" ^ showArray (showArray I.toString) t1 ^ ")"
       | Complex t2 =>
        "Complex " ^ "("
        ^
        showArray
          (showArray (fn {re = t0, im = t1} =>
             "{"
             ^
             String.concatWith ", "
               ["re = " ^ R.toString t0, "im = " ^ R.toString t1] ^ "}")) t2
        ^ ")"
    val show = showColumns
  end


  structure Values =
  struct
    datatype values =
      Real of R.real array
    | Integer of I.int array array
    | Complex of {re: R.real, im: R.real} array
    type t = values

    (* generated by smlgen / tweaked by hand *)
    val showValues =
      fn Real t0 => "Real " ^ "(" ^ showArray R.toString t0 ^ ")"
       | Integer t1 =>
        "Integer " ^ "(" ^ showArray (showArray I.toString) t1 ^ ")"
       | Complex t2 =>
        "Complex " ^ "("
        ^
        showArray
          (fn {re = t0, im = t1} =>
             "{"
             ^
             String.concatWith ", "
               ["re = " ^ R.toString t0, "im = " ^ R.toString t1] ^ "}") t2
        ^ ")"
    val show = showValues
  end


  datatype data =
    Array of Columns.t
  | Coordinate of
      {row_indices: I.int array, col_indices: I.int array, values: Values.t}
  | Pattern of {row_indices: I.int array, col_indices: I.int array}

  (* generated by smlgen / tweaked by hand *)
  val showData =
    fn Array t0 => "Array " ^ "(" ^ Columns.show t0 ^ ")"
     | Coordinate {row_indices = t1, col_indices = t2, values = t3} =>
      "Coordinate " ^ "{"
      ^
      String.concatWith ", "
        [ "row_indices = " ^ showArray I.toString t1
        , "col_indices = " ^ showArray I.toString t2
        , "values = " ^ Values.show t3
        ] ^ "}"
     | Pattern {row_indices = t4, col_indices = t5} =>
      "Pattern " ^ "{"
      ^
      String.concatWith ", "
        [ "row_indices = " ^ showArray I.toString t4
        , "col_indices = " ^ showArray I.toString t5
        ] ^ "}"


  datatype symmetry = General | SkewSymmetric | Symmetric | Hermitian

  (* generated by smlgen *)
  val showSymmetry =
    fn General => "General"
     | SkewSymmetric => "SkewSymmetric"
     | Symmetric => "Symmetric"
     | Hermitian => "Hermitian"


  datatype matrix =
    Matrix of {width: int, height: int, data: data, symm: symmetry}


  (* generated by smlgen / tweaked by hand *)
  val showMatrix = fn Matrix {width = t0, height = t1, data = t2, symm = t3} =>
    "Matrix " ^ "{"
    ^
    String.concatWith ", "
      [ "width = " ^ Int.toString t0
      , "height = " ^ Int.toString t1
      , "data = " ^ showData t2
      , "symm = " ^ showSymmetry t3
      ] ^ "}"


  (* check if str is at the beginning of chars *)
  fun begins_with (str: string) (chars: char Seq.t) =
    String.size str <= Seq.length chars
    andalso
    Util.all (0, String.size str) (fn i =>
      String.sub (str, i) = Seq.nth chars i)


  fun error path msg =
    raise Fail ("MatrixMarket: " ^ path ^ ": " ^ msg)


  structure Header =
  struct
    datatype first_field = Coordinate | Array
    datatype second_field = Real | Integer | Complex | Pattern
    datatype third_field = General | Symmetric | SkewSymmetric | Hermitian

    fun parse path (chars: char Seq.t) =
      let
        fun skip_whitespace chars =
          case
            FindFirst.findFirstSerial (0, Seq.length chars)
              (not o Char.isSpace o Seq.nth chars)
          of
            SOME i => Seq.drop chars i
          | NONE => Seq.drop chars (Seq.length chars)

        fun expect chars str {err: string} =
          if begins_with str chars then Seq.drop chars (String.size str)
          else error path err

        fun test chars str =
          if begins_with str chars then SOME (Seq.drop chars (String.size str))
          else NONE

        val chars =
          expect chars "%%MatrixMarket matrix" {err = "not a MatrixMarket file"}


        fun try_each chars err_msg tests =
          case tests of
            [] => error path err_msg
          | (str, result) :: tests' =>
              case test chars str of
                SOME chars => (result, chars)
              | NONE => try_each chars err_msg tests'


        val chars = skip_whitespace chars
        val (first_field, chars) =
          try_each chars
            "first field in header must be one of: coordinate, array"
            [("coordinate", Coordinate), ("array", Array)]

        val chars = skip_whitespace chars
        val (second_field, chars) =
          try_each chars
            "second field in header must be one of: real, integer, complex, pattern"
            [ ("real", Real)
            , ("integer", Integer)
            , ("complex", Complex)
            , ("pattern", Pattern)
            ]

        val chars = skip_whitespace chars
        val (third_field, chars) =
          try_each chars
            "third field in header must be one of: general, symmetric, skew-symmetric, Hermitian"
            [ ("general", General)
            , ("symmetric", Symmetric)
            , ("skew-symmetric", SkewSymmetric)
            , ("Hermitian", Hermitian)
            ]
      in
        (first_field, second_field, third_field)
      end

  end


  fun emp () = Array.fromList []


  fun read_file (path: string) =
    let
      val contents = ReadFile.contentsSeq path

      val (num_lines, get_line_range) =
        Tokenize.tokenRanges (fn c => c = #"\n") contents

      fun make_line i =
        let val (start, stop) = get_line_range i
        in Seq.subseq contents (start, stop - start)
        end

      val () =
        if num_lines > 0 then ()
        else error path "invalid file: not enough lines to parse"

      val (f1, f2, f3) = Header.parse path (make_line 0)

      val data =
        case f1 of
          Header.Coordinate =>
            (case f2 of
               Header.Real =>
                 Coordinate
                   { row_indices = emp ()
                   , col_indices = emp ()
                   , values = Values.Real (emp ())
                   }
             | Header.Integer =>
                 Coordinate
                   { row_indices = emp ()
                   , col_indices = emp ()
                   , values = Values.Integer (emp ())
                   }
             | Header.Complex =>
                 Coordinate
                   { row_indices = emp ()
                   , col_indices = emp ()
                   , values = Values.Complex (emp ())
                   }
             | Header.Pattern =>
                 Pattern {row_indices = emp (), col_indices = emp ()})

        | Header.Array =>
            (case f2 of
               Header.Real => Array (Columns.Real (emp ()))
             | Header.Integer => Array (Columns.Integer (emp ()))
             | Header.Complex => Array (Columns.Complex (emp ()))
             | Header.Pattern =>
                 error path
                   "invalid header: array cannot be combined with pattern")
    in
      print
        "[MatrixMarket.read_file: WARNING: work-in-progress: function not completed yet]\n";

      Matrix
        { width = 0
        , height = 0
        , data = data
        , symm =
            case f3 of
              Header.General => General
            | Header.Symmetric => Symmetric
            | Header.SkewSymmetric => SkewSymmetric
            | Header.Hermitian => Hermitian
        }
    end

end
